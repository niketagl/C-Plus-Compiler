struct apple
{
	int a;
};

int a;

int swap( int tt ) 
{
	int a,b,d,e,f; 
	float x[9];
	int c;
	c <<= b;
	d >>= e;
	a+b+c+d+e+f;
	// 5;
	// 012;
	// 0x32;
	// 'a';
	// '\n';
	// L'a';
	// L'\'';
	// float g = 345e+4;
 //    float h = 12e-1;
 //    float i = .23e2;
 //    float j = 32.e-2;
} 

// #define el 0

// /* This function takes last element as pivot, places 
// the pivot element at its correct position in sorted 
// 	array, and places all smaller (smaller than pivot) 
// to left of pivot and all greater elements to right 
// of pivot */
// int partition (int arr[], int low, int high) 
// { 
// 	int pivot = arr[high];  
// 	int i = (low - 1);  
// 	for(int i=0; i<10; i++ ){
// 		//j++;
// 	}

// 	for (j = low; j <= high- 1; j++) 
// 	{ 
// 		if (arr[j] <= pivot) 
// 		{ 
// 			i++;  
// 			swap(&arr[i], &arr[j]); 
// 		} 
// 	} 
// 	swap(&arr[i + 1], &arr[high]); 
// 	return (i + 1); 
// } 

// /* The main function that implements QuickSort 
// arr[] --> Array to be sorted, 
// low --> Starting index, 
// high --> Ending index */
// void quickSort(int arr[], int low, int high) 
// { 
// 	if (low < high) 
// 	{ 
// 		/* pi is partitioning index, arr[p] is now 
// 		at right place */
// 		int pi = partition(arr, low, high); 

// 		// Separately sort elements before 
// 		// partition and after partition 
// 		quickSort(arr, low, pi - 1); 
// 		quickSort(arr, pi + 1, high); 
// 	} 
// } 

// /* Function to print an array */
// void printArray(int arr[], int size) 
// { 
// 	int i; 
// 	for (i=0; i < size; i++) 
// 		printf("%d ", arr[i]); 
// 	printf("n"); 
// } 

// // Driver program to test above functions 
// int main() 
// {
// 	int ,i = min->size -1; 
// 	int arr[] = {10, 7, 8, 9, 1, 5}; 
// 	int n = sizeof(arr)/sizeof(arr[0]); 
// 	quickSort(arr, 0, n-1); 
// 	printf("Sorted array: n"); 
// 	printArray( , n); 
// 	return 0; 
// } 
// void insertMinHeap(struct MinHeap* minHeap, 
// 				struct MinHeapNode* minHeapNode) 

// { 

		
// 	//int i = minHeap->size - 1; 
		
// 		int  i= minHeap->size - 1; 
// 		++minHeap->size ; 

// 	while (i && minHeapNode.freq <= minHeap->array[(i - 1) / 2]->freq) { 

// 		minHeap->array[i] = minHeap->array[(i - 1) / 2]; 
// 		i = (i - 1) / 2; 
// 	} 
// 	int x;
// 	minHeap->array[i] = minHeapNode 
// } 